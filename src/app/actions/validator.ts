'use server'

import { GoogleGenAI } from "@google/genai"
import { createClient } from "@/lib/supabase/server"

export async function runValidatorAgent(jobId: string) {
    const supabase = await createClient()
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) throw new Error("Unauthorized")

    const { data: job } = await supabase.from('job_logs').select('*').eq('id', jobId).single()
    const { data: profile } = await supabase.from('user_profiles').select('*').eq('id', user.id).single()

    if (!job || !profile || !job.resume_content) throw new Error("Missing data")

    const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY })

    const prompt = `
You are the Nexatask Validator & ATS Analytics Agent.
Your job is to read the user's original Master Resume, the new Tailored Resume generated by our AI, and the Target Job Description. 

You must perform a deep dual-analysis and output an "ATS Match Report". 
1. Evaluate the user's Master Resume against the Job Description. Generate a "Before" ATS score (1-100).
2. Evaluate the Tailored Resume against the Job Description. Generate an "After" ATS score (1-100).
3. Identify the specific "Skill Gaps Closed"â€”which critical keywords or implicit requirements from the JD were successfully injected or creatively aligned into the Tailored Resume that were missing or weak in the Master Resume.
4. Confirm whether the final Tailored Resume is highly professional and effective.

Output strictly valid JSON:
{
  "passed": boolean, // true if the tailored resume is strong and professional; false ONLY if it is completely irrelevant, contains obvious placeholders, or is unreadable.
  "report": "string, A supportive, encouraging review of how well the tailored resume targets the job.",
  "analysis": {
    "before_score": number, // 1-100
    "after_score": number, // 1-100
    "skill_gaps_closed": ["keyword/skill 1", "keyword/skill 2", "keyword/skill 3"] // 3 to 6 strings
  }
}

======= USER_BASE_PROFILE =======
Name: ${profile.name}
Location: ${profile.location}
Education: ${profile.education}
Certifications: ${profile.certifications?.join(', ')}
======= END_USER_BASE_PROFILE =======

======= MASTER_RESUME (BEFORE) =======
${profile.master_resume || "None provided"}
======= END_MASTER_RESUME =======

======= TARGET_JOB =======
Title: ${job.title}
Description: ${job.description}
======= END_TARGET_JOB =======

======= TAILORED_RESUME_PAYLOAD (AFTER) =======
${job.resume_content}
======= END_TAILORED_RESUME_PAYLOAD =======
`

    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: prompt,
            config: {
                responseMimeType: "application/json",
            }
        })

        const resultStr = response.text
        if (!resultStr) throw new Error("No output generated")

        let cleanJsonText = resultStr.trim();
        if (cleanJsonText.startsWith("\`\`\`")) {
            const lines = cleanJsonText.split('\n');
            if (lines[0].startsWith("\`\`\`")) lines.shift();
            if (lines[lines.length - 1].startsWith("\`\`\`")) lines.pop();
            cleanJsonText = lines.join('\n').trim();
        }

        const result = JSON.parse(cleanJsonText)
        const newStatus = result.passed ? 'validated' : 'failed_validation'

        const { error } = await supabase.from('job_logs').update({
            validation_report: JSON.stringify(result),
            status: newStatus
        }).eq('id', jobId)

        if (error) {
            console.error(error)
            throw new Error("Failed to save validation report")
        }

        return { success: true, status: newStatus, report: JSON.stringify(result), passed: result.passed }
    } catch (err: any) {
        console.error("Validator error", err)
        return { error: "Validator Agent execution failed: " + err.message }
    }
}
